# GEMINI.md

## プロジェクト概要

Rustを使ってcastnowのforkを作る

## 技術スタック

- **開発言語**: rust
- **formatter**: rustfmt
- **linter**: clippy

## ディレクトリ構成 (想定)

```
/
├── Cargo.toml            # Rustプロジェクトのマニフェストファイル
├── src/                  # Rustソースコード
│   ├── main.rs           # メインアプリケーションのエントリーポイント
│   └── lib.rs            # ライブラリコード
└── target/               # コンパイルされたバイナリと成果物
```

## 開発プロセス

### テスト駆動開発 (TDD)

本プロジェクトではテスト駆動開発 (TDD) を採用します。以下のサイクルで開発を進めます。

1.  **テストの実装**: 最初に、これから実装する機能のテストコードを記述します。このテストは、まだ機能が実装されていないため、失敗するはずです。
2.  **テストの実行**: 記述したテストを実行し、失敗することを確認します。これにより、テストが正しく機能していることを確認します。
3.  **コードの実装**: テストが成功するように、最小限のコードを実装します。
4.  **テストの実行**: 再びテストを実行し、すべてのテストが成功することを確認します。

### テストの記述

モジュール内の関数などの単体テストは、`#[cfg(test)]` 属性を使用して、テスト対象のモジュール内に直接記述します。これにより、テストコードが本番ビルドに含まれるのを防ぎつつ、関連するコードとテストを近くに保つことができます。

```rust
// src/lib.rs または src/module_name.rs

pub fn my_function() {
    // ...
}

#[cfg(test)]
mod tests {
    use super::*; // 親モジュールのアイテムをインポート

    #[test]
    fn test_my_function() {
        // テストコード
        assert_eq!(my_function(), "expected_value");
    }
}
```

### 統合テスト

統合テストは、複数のモジュールやコンポーネントが連携して正しく動作するかを検証します。システム全体の挙動を確認するため、エンドツーエンドのテストも含まれることがあります。

統合テストは`tests/`ディレクトリ内に配置します。共通のテストヘルパー関数やフィクスチャは、`tests/`内に`common`モジュールとしてまとめ、複数のテストで再利用します。

```
/
└── tests/
    ├── common/             # 共通のテストヘルパー関数やフィクスチャ
    │   └── mod.rs
    ├── integration_test1.rs
    └── integration_test2.rs
```

### 統合テスト

統合テストは、複数のモジュールやコンポーネントが連携して正しく動作するかを検証します。システム全体の挙動を確認するため、エンドツーエンドのテストも含まれることがあります。

統合テストは`tests/`ディレクトリ内に配置します。共通のテストヘルパー関数やフィクスチャは、`tests/`内に`helpers`モジュールとしてまとめ、複数のテストで再利用します。

```
/
└── tests/
    ├── common/             # 共通のテストヘルパー関数やフィクスチャ
    │   └── mod.rs
    ├── integration_test1.rs
    └── integration_test2.rs
```

### コード品質チェック

コードの修正を行った場合、以下のコマンドを実行してフォーマットとリントのエラーがないか確認します。

- `cargo fmt`: コードのフォーマットを自動修正します。
- `cargo clippy`: コードのリントを実行し、潜在的な問題を検出します。

**コードのステージング前**: 変更をステージングする前に、必ず `cargo fmt`、`cargo clippy`、`cargo test` を実行し、すべてのチェックがパスすることを確認してください。

## ブランチ戦略

本プロジェクトでは、GitHub Flow をブランチ戦略として採用します。

### GitHub Flow のルール

GitHub Flow は、継続的デリバリーを重視したシンプルで効果的なブランチ戦略です。

1.  **`main` ブランチは常にデプロイ可能である**: `main` ブランチは常に安定しており、いつでも本番環境にデプロイできる状態を保ちます。
2.  **新しい作業はすべて新しいブランチで**: 新しい機能、バグ修正、またはその他の変更を行う際は、必ず `main` ブランチから新しいブランチを作成します。ブランチ名は、その作業内容を簡潔に表すものにします（例: `add-user-authentication`, `fix-login-bug`）。
3.  **定期的にコミットし、リモートにプッシュする**: 作業中は、小さな単位で頻繁にコミットし、定期的にリモートブランチにプッシュします。これにより、作業の進捗が共有され、他のメンバーとの衝突を最小限に抑えられます。
4.  **プルリクエストを開く**: 機能が完成した、またはフィードバックが必要な段階になったら、プルリクエスト（PR）を開きます。PRは、変更内容の議論、コードレビュー、自動テストの実行の場となります。
5.  **レビューとテスト**: PRが承認され、すべてのテストがパスしたら、`main` ブランチにマージします。
6.  **デプロイ**: `main` ブランチにマージされたら、すぐにデプロイします。

## 主なコマンド

- `cargo fmt`: formatter
- `cargo clippy`: linter

### コミット

`commitして`という指示があった場合、変更をステージングしてからコミットします。
コミットメッセージは英語で記述してください。

**注意**: `.gitignore` ファイルは非常に重要なファイルであるため、変更する際は追記のみを行ってください。

### コミットメッセージの作成

複数行のコミットメッセージを作成する場合、以下の手順でコミットしてください。

1. コミットメッセージを一時ファイルに書き込みます。
   `write_file(content="<コミットメッセージ>", file_path="/workspace/commit_message.txt")`
2. 一時ファイルを指定してコミットします。
   `git commit -F /workspace/commit_message.txt`
3. コミット後、一時ファイルを削除します。
   `rm /workspace/commit_message.txt`

### Issue の確認

`issueを確認して`という指示があった場合、`gh issue view <issue番号>`または`gh issue list`を使用します。

### Issue の登録

`issueを登録して`という指示があった場合、以下の手順で issue を登録します。
issue のタイトルと本文は日本語で記述してください。

1. issue の本文を一時ファイルに書き込みます。
   `write_file(content="<issue本文>", file_path="/workspace/issue_body.md")`
2. 一時ファイルを指定して issue を登録します。
   `gh issue create --title "<issueタイトル>" --body-file /workspace/issue_body.md`
3. issue 登録後、一時ファイルを削除します。
   `rm /workspace/issue_body.md`



### プルリクエストのコメント

`プルリクエストにコメントして`という指示があった場合、以下の手順でコメントを登録します。

1. コメント本文を一時ファイルに書き込みます。
   `write_file(content="<コメント本文>", file_path="/workspace/pr_comment.txt")`
2. 一時ファイルを指定してコメントを登録します。
   `gh pr comment <プルリクエスト番号> --body-file /workspace/pr_comment.txt`
3. コメント登録後、一時ファイルを削除します。
   `rm /workspace/pr_comment.txt`

### プルリクエストの作成

`プルリクエストを作成して`という指示があった場合、以下の手順でプルリクエストを作成します。
プルリクエストのタイトルと本文は日本語で記述してください。

1. プルリクエストの本文を一時ファイルに書き込みます。
   `write_file(content="<プルリクエスト本文>", file_path="/workspace/pr_body.md")`
2. 一時ファイルを指定してプルリクエストを作成します。
   `gh pr create --title "<プルリクエストタイトル>" --body-file /workspace/pr_body.md`
3. プルリクエスト作成後、一時ファイルを削除します。
   `rm /workspace/pr_body.md`
